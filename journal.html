<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning Journal PWA - Weekly Entries</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>

   <div id="nav-placeholder"></div>
   <button id="theme-toggle">Switch to Dark Mode</button>

   <main class="journal-page">
        <h1>Weekly Learning Journal</h1>
        <p>This section contains reflections and insights from each week of the module, serving as the required learning log.</p>
        
        <section class="new-entry-form">
            <h2>Add New Journal Entry</h2>
            <form id="entry-form">
                <label for="entry-title">Title:</label>
                <input type="text" id="entry-title" required>
                
                <label for="entry-content">Content:</label>
                <textarea id="entry-content" rows="5" required></textarea>
                
                <button type="submit">Save Entry</button>
            </form>
        </section>

        <!-- NEW: Data Management Section -->
<section class="export-section">
    <h3> Export All Entries</h3>
    <p>Download all your journal entries (browser + Python) as a JSON file</p>
    <button id="export-btn" class="export-button">Export All Entries</button>
</section>

        <section id="saved-entries-container">
            <!-- Custom entries will be loaded here dynamically -->
        </section>
        
        <article class="journal-entry">
            <h2>Week 5: Python & JSON Backend Data (Lab 5)</h2>
            <p>Goal: Extend the Learning Journal PWA by introducing Python and JSON as tools for storing reflections in a file-based backend system.</p>
            
            <h3>Journal Questions:</h3>
            <ol>
                <li><strong>How is storing data in a JSON file different from using browser storage?</strong><br>
                    I implemented a dual-storage system where browser storage (localStorage) handles immediate saves from the web interface, while JSON files serve as a Python-editable backend. Browser storage is device-specific and persists only in that browser, while JSON files are server-side files that can be edited externally and act as a universal backup. The system automatically merges both sources and removes duplicates when displaying entries.
                </li>
                <li><strong>How did you use Python to create or update your JSON file?</strong><br>
                    I created a Python script (`save_entry.py`) that uses the built-in `json` module to read and write JSON files. The script prompts the user for entry title and content, creates an entry object matching the JavaScript structure (with id, title, content, date, time, and source fields), loads existing entries from the JSON file, appends the new entry, and saves the updated array back to the file using `json.dump()` with proper formatting.
                </li>
                <li><strong>What does your PWA show locally, and what will users see on GitHub? Are they the same? Why or why not?</strong><br>
                    Locally, users see a combined view of all entries from both browser storage and the JSON file. On GitHub Pages, users only see the pre-committed JSON file entries. They are not the same because localStorage is device-specific and doesn't transfer to GitHub's servers, and the Python script cannot execute on static hosting. This demonstrates the difference between client-side and server-side data persistence.
                </li>
                <li><strong>What extra feature did you add to your PWA using the JSON file, and why?</strong><br>
                    I implemented an Export/Import system that allows users to download all their entries (from both storage sources) as a JSON file and import entries from external JSON files. This provides complete data portability, backup capabilities, and gives users full control over their learning journal data, aligning with the reflective purpose of the application.
                </li>
            </ol>
        </article>

        <article class="journal-entry">
            <h2>Week 4: Introduction to API (Lab 4)</h2>
            <p id="entry-content-w4">Goal: Extended the Learning Journal PWA by integrating three different types of APIs (Storage, Browser, and Third-Party) to enhance persistence and interactivity.</p>
            <button class="copy-button" data-target="entry-content-w4">Copy Entry</button>
            <h3>Journal Questions:</h3>
            <ol>
                <li><strong>Which Storage, Browser, and Third-Party APIs did you choose, and why?</strong><br>
                    I chose the Local Storage API for persistent data storage because it is simple, fast, and ideal for saving light structured data like user-submitted journal entries directly in the browser. I chose the Clipboard API for the Browser API task as it provides useful, modern user functionality (copying text) that significantly improves the journal page's usability. Finally, I chose the Spotify Widget (iFrame) for the Third-Party API because it is a fast and simple method to integrate rich, external media content (music) into the About page.
                </li>
                <li><strong>How did you integrate each API with DOM manipulation?</strong><br>
                    For the Local Storage API, DOM manipulation was crucial: upon page load, JavaScript retrieved the stored JSON array of entries, converted it back to HTML strings, and used `container.innerHTML` to display the content in the `saved-entries-container`. For the Clipboard API, an event listener was attached to copy buttons, and DOM manipulation was used to change the button's `textContent` from "Copy Entry" to "Copied!" for 1.5 seconds, providing user feedback. The Spotify Widget was integrated by placing its static `iframe` structure directly into the `about.html` file.
                </li>
                <li><strong>What challenges did you encounter, and how did you solve them?</strong><br>
                    The main challenge was ensuring the dynamically created content from the Storage API worked with the Clipboard API. When a user saves a new entry, the copy button for that entry must also work. I solved this by using an event delegation approach: instead of attaching click listeners directly to each button (which would fail for new buttons), I listened for clicks on the document and checked if the clicked element had the class `copy-button`. This ensures copy functionality works for both static and dynamically created entries.
                </li>
                <li><strong>In what ways do these APIs improve your Learning Journal PWA?</strong><br>
                    These APIs significantly improve the PWA's functionality. The Local Storage gives the application persistence, meaning user-submitted journal entries are never lost. The Clipboard API adds a useful quality-of-life feature, simplifying the sharing or archiving of entries. The Spotify Widget makes the profile page more engaging by integrating external, multimedia content, fulfilling the goal of making the PWA more powerful and interactive.
                </li>
            </ol>
        </article>

        <article class="journal-entry">
            <h2>Week 3: JavaScript & DOM Manipulation (Lab 3)</h2>
            <p id="entry-content-w3">Goal: Enhanced the Learning Journal PWA by adding a reusable navigation menu and an interactive Theme Switcher using JavaScript and the HTML DOM.</p>
            <button class="copy-button" data-target="entry-content-w3">Copy Entry</button>
            <h3>Journal Questions:</h3>
            <ol>
                <li><strong>Which DOM selection methods did you use, and why did you choose them?</strong><br>
                    I used two primary methods: document.getElementById() and document.querySelectorAll(). I chose `getElementById()` (used for selecting the navigation placeholder and the theme button) because it is the fastest method and guaranteed to select only one unique element. I chose `querySelectorAll()` (used for selecting all navigation links) because it returns a list of elements that can be efficiently looped over to apply the active class or attach event listeners.
                </li>
                <li><strong>What was the most challenging part about linking JavaScript with your HTML?</strong><br>
                    The most challenging part was ensuring the reusable navigation code correctly determined which page was currently loaded to apply the `class="active"`. I encountered an error where the script failed to correctly identify the homepage file name (`index.html`) when deployed, leading to incorrect highlighting. This was fixed by implementing logic in JavaScript to specifically check for an empty path and default to 'index.html'.
                </li>
                <li><strong>How did you test and debug your JavaScript code?</strong><br>
                    I primarily tested and debugged using the browser's Developer Tools. I used the Console to check if variables were holding the correct page paths and if functions were running when expected. I used the Elements tab to verify that the `dark-mode` CSS class was being correctly added to the `<body>` element on button clicks, and that the `active` class was being applied to the correct navigation link.
                </li>
            </ol>
        </article>

        
        <article class="journal-entry">
            <h2>Week 2: Frontend Fundamentals (Lab 2)</h2>
            <p id="entry-content-w2">Goal: Established the basic structure, layout, and navigation of the Learning Journal PWA using only HTML and CSS, with a focus on responsive, mobile-first design.</p>
            <button class="copy-button" data-target="entry-content-w2">Copy Entry</button>
            <h3>Journal Questions:</h3>
            <ol>
                <li><strong>How did you approach mobile-first design?</strong><br>
                    I adopted a mobile-first strategy by ensuring the CSS was written primarily for small screen sizes (phones) by default. I first styled the main elements, such as the body, fonts, and colours. Critically, I used Flexbox on the navigation (nav ul) to stack the links vertically (flex-direction: column), making them large touch targets suitable for mobile. Only after the mobile layout was complete did I use a CSS media query (@media screen and (min-width: 768px)) to override those styles, changing the navigation to a horizontal row and centering the content for tablet and desktop views.
                </li>
                <li><strong>What was the most useful HTML or CSS concept you applied this week?</strong><br>
                    The most useful concept was Flexbox. It was essential for creating a responsive navigation bar. By switching the flex-direction property based on screen size, I maintained layout consistency and adapted the design effectively between mobile and desktop. This satisfied the requirement to build the skeleton structure and design layout using HTML and CSS only.
                </li>
                <li><strong>What part of HTML or CSS did you find most challenging or confusing?</strong><br>
                    The most challenging part was ensuring the "active" page highlighting worked correctly across all four HTML pages (index.html, journal.html, etc.). Since JavaScript was excluded for this week's task, I had to manually place the class="active" tag on the current page's link in each of the four separate HTML files. This repeated manual effort was tedious and highlighted the need for a templating system or JavaScript component loading for navigation reusability in future weeks.
                </li>
            </ol>
        </article>

        <article class="journal-entry">
            <h2>Week 1: Introduction and PWA (Lab 1)</h2>
            <p id="entry-content-w1">Goal: Become familiar with running applications across multiple platforms (GitHub, VS Code, PythonAnywhere, Android Studio) by building the Temperature Converter PWA.</p>
            <button class="copy-button" data-target="entry-content-w1">Copy Entry</button>
            <h3>Lab 1 Reflection and Challenges:</h3>
            <ul>
                <li><strong>Steps Followed & Technologies:</strong> Describe the steps using GitHub, VS Code, PythonAnywhere, Android Studio, PWA, and Kotlin code.<br>
                    The lab began with GitHub setup, creating the Temperature ConverterPWA repository and integrating with VS Code by installing Git and the GitHub extensions. I used VS Code to open the repository remotely, create the initial index.html and commit the changes. Next, I deployed the site using GitHub Pages after changing the repository visibility to public. The PWA was built by adding the **manifest.json** for installability, the main UI (HTML form, converter.css for styling, and converter.js for conversion logic). Finally, a Service Worker (sw.js) was added to enable offline functionality. I also tested deploying the same files to PythonAnywhere and followed instructions to run a Kotlin-based Temperature Converter app in Android Studio.
                </li>
                <li><strong>Challenges Faced:</strong> Describe any difficulties you encountered while running the code or configuring the platforms.<br>
                    One challenge was ensuring the correct relative paths were used for the PWA manifest and Service Worker references (e.g., /manifest.json and /sw.js). Incorrect paths prevented the app from being installed or working offline. Another area of complexity was setting up Android Studio and running the Kotlin app, as it required downloading and configuring SDKs and emulators, which was significantly more complex than the web deployments (GitHub Pages and PythonAnywhere).
                </li>
            </ul>
        </article>
        
    </main>

    <footer>
        <p>Â© 2025 Ramesh Chaudhary. All rights reserved.</p>
    </footer>
    
    <script src="js/storage.js"></script>
    <script src="js/browser.js"></script>
    <script src="js/script.js"></script>
</body>
</html>