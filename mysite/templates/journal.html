<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning Journal PWA - Weekly Entries</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>

   <div id="nav-placeholder"></div>
   <button id="theme-toggle">Switch to Dark Mode</button>

   <main class="journal-page">
        <h1>Weekly Learning Journal</h1>
        <p>This section contains reflections and insights from each week of the module, serving as the required learning log.</p>

        <section class="new-entry-form">
            <h2>Add New Journal Entry</h2>
            <form id="entry-form">
                <label for="entry-title">Title:</label>
                <input type="text" id="entry-title" required>

                <label for="entry-content">Content:</label>
                <textarea id="entry-content" rows="5" required></textarea>

                <button type="submit">Save Entry</button>
            </form>
        </section>

        <section class="export-section">
    <h3> Export All Entries</h3>
    <p>Download all your journal entries (browser + Python) as a JSON file</p>
    <button id="export-btn" class="export-button">Export All Entries</button>
</section>

        <section id="saved-entries-container">
            </section>

            <article class="journal-entry">
            <h2>Week 7: Progressive Web Apps (Lab 7)</h2>
            <p id="entry-content-w7">Goal: Transform the Learning Journal into a fully installable Progressive Web App (PWA) with offline capabilities using Service Workers and the Web Manifest.</p>
            <button class="copy-button" data-target="entry-content-w7">Copy Entry</button>
            <h3>Journal Questions:</h3>
            <ol>
                <li><strong>Why is it useful to enhance your Flask app with PWA features?</strong><br>
                    Enhancing the Flask app with PWA features bridges the gap between a standard website and a native mobile application. It allows the journal to be installed directly on the home screen with a custom icon, removing the browser address bar for a more immersive feel. Crucially, it ensures the app remains functional even when the network is unstable or offline, preventing the user from seeing error pages.
                </li>
                <li><strong>What did you use to support offline access and dynamic data?</strong><br>
                    I implemented a Service Worker (`sw.js`) to intercept network requests. To handle dynamic data like journal entries, I used a <strong>Network First</strong> strategy: the app attempts to fetch fresh data from the Flask API first, and if that fails (offline), it retrieves the saved copy from the Cache Storage. For static assets like images and CSS, I used a <strong>Cache First</strong> strategy to ensure they load instantly.
                </li>
                <li><strong>What extra feature did you add, and why?</strong><br>
                    I implemented a <strong>Custom "Install App" Button</strong>. By listening for the browser's `beforeinstallprompt` event, I prevented the default behavior and instead displayed a prominent purple button in the UI. I added this because standard browser install options are often hidden inside menus; a visible button significantly improves the user experience by making the installation process obvious and accessible.
                </li>
                <li><strong>Did you face any challenges deploying your PWA, and how did you solve them?</strong><br>
                    My biggest challenge was the Service Worker Scope. By default, a service worker in the `static/js/` folder cannot control the root HTML pages. I solved this by configuring a specific route in my Flask backend (`flask_app.py`) to serve the `sw.js` file from the root URL (`/sw.js`) and explicitly adding the `Service-Worker-Allowed: /` header. This allowed the service worker to cache the entire application correctly.
                </li>
            </ol>
        </article>

        <article class="journal-entry">
            <h2>Week 6: Flask Backend & PWA Integration (Lab 6)</h2>
            <p id="entry-content-w6">Goal: Successfully integrate a Flask backend deployed on PythonAnywhere with the Learning Journal PWA, enabling server-side JSON data management via API requests.</p>
            <button class="copy-button" data-target="entry-content-w6">Copy Entry</button>
            <h3>Journal Questions:</h3>
            <ol>
                <li><strong>Why is the frontend-backend connection important?</strong><br>
                    The frontend-backend connection is crucial because it allows the application to manage persistent, universal data. The frontend (HTML/CSS/JS) handles the user interface and presentation, while the backend (Flask/Python) manages business logic, security, and storing data in a central location, like a JSON file.
                </li>
                <li><strong>Which HTTP methods did you use in Flask, and why?</strong><br>
                    I used GET, POST, and DELETE methods. GET is used by the frontend to fetch all existing journal entries from the server for display. POST is used to submit new journal entries from the form to the Flask server to be appended to the JSON file. DELETE (the extra feature) is used to send a request to the server to remove a specific entry by ID.
                </li>
                <li><strong>What is the difference between using Flask to store and load JSON data and reading JSON directly in the browser?</strong><br>
                    Reading JSON directly in the browser only works for static files (read-only) and is limited to client-side data. Using Flask to store and load JSON data means the data is handled by the server (backend). This allows for dynamic actions like saving new data (POST) or deleting old data (DELETE), ensuring the data is persistent across user sessions and devices, which is impossible with a direct file read.
                </li>
                <li><strong>Did you face any difficulties when running your project on PythonAnywhere? How did you handle them?</strong><br>
                    The main difficulties were ensuring file paths were correctly configured for the `reflections.json` file (as it was nested in `/static/backend`), and fixing the navigation links. The path issue was fixed by updating the `DATA_FILE` variable in `flask_app.py`. The navigation issue was solved by removing the faulty JavaScript injection and implementing server-side rendering using Jinja2's `url_for` and `request.path` logic directly in the HTML templates.
                </li>
                <li><strong>What extra feature did you build into your PWA with Flask, and why did you add it?</strong><br>
                    I implemented a DELETE route that allows users to permanently delete server-stored entries from the `reflections.json` file. I added this to provide full CRUD (Create, Read, Update, Delete) functionality to the journal, giving the user complete control over their server-side data.
                </li>
            </ol>
        </article>

        <article class="journal-entry">
            <h2>Week 5: Python & JSON Backend Data (Lab 5)</h2>
            <p>Goal: Extend the Learning Journal PWA by introducing Python and JSON as tools for storing reflections in a file-based backend system.</p>

            <h3>Journal Questions:</h3>
            <ol>
                <li><strong>How is storing data in a JSON file different from using browser storage?</strong><br>
                    I implemented a dual-storage system where browser storage (localStorage) handles immediate saves from the web interface, while JSON files serve as a Python-editable backend. Browser storage is device-specific and persists only in that browser, while JSON files are server-side files that can be edited externally and act as a universal backup. The system automatically merges both sources and removes duplicates when displaying entries.
                </li>
                <li><strong>How did you use Python to create or update your JSON file?</strong><br>
                    I created a Python script (`save_entry.py`) that uses the built-in `json` module to read and write JSON files. The script prompts the user for entry title and content, creates an entry object matching the JavaScript structure (with id, title, content, date, time, and source fields), loads existing entries from the JSON file, appends the new entry, and saves the updated array back to the file using `json.dump()` with proper formatting.
                </li>
                <li><strong>What does your PWA show locally, and what will users see on GitHub? Are they the same? Why or why not?</strong><br>
                    Locally, users see a combined view of all entries from both browser storage and the JSON file. On GitHub Pages, users only see the pre-committed JSON file entries. They are not the same because localStorage is device-specific and doesn't transfer to GitHub's servers, and the Python script cannot execute on static hosting. This demonstrates the difference between client-side and server-side data persistence.
                </li>
                <li><strong>What extra feature did you add to your PWA using the JSON file, and why?</strong><br>
                    I implemented an Export/Import system that allows users to download all their entries (from both storage sources) as a JSON file and import entries from external JSON files. This provides complete data portability, backup capabilities, and gives users full control over their learning journal data, aligning with the reflective purpose of the application.
                </li>
            </ol>
        </article>

        <article class="journal-entry">
            <h2>Week 4: Introduction to API (Lab 4)</h2>
            <p id="entry-content-w4">Goal: Extended the Learning Journal PWA by integrating three different types of APIs (Storage, Browser, and Third-Party) to enhance persistence and interactivity.</p>
            <button class="copy-button" data-target="entry-content-w4">Copy Entry</button>
            <h3>Journal Questions:</h3>
            <ol>
                <li><strong>Which Storage, Browser, and Third-Party APIs did you choose, and why?</strong><br>
                    I chose the Local Storage API for persistent data storage because it is simple, fast, and ideal for saving light structured data like user-submitted journal entries directly in the browser. I chose the Clipboard API for the Browser API task as it provides useful, modern user functionality (copying text) that significantly improves the journal page's usability. Finally, I chose the Spotify Widget (iFrame) for the Third-Party API because it is a fast and simple method to integrate rich, external media content (music) into the About page.
                </li>
                <li><strong>How did you integrate each API with DOM manipulation?</strong><br>
                    For the Local Storage API, DOM manipulation was crucial: upon page load, JavaScript retrieved the stored JSON array of entries, converted it back to HTML strings, and used `container.innerHTML` to display the content in the `saved-entries-container`. For the Clipboard API, an event listener was attached to copy buttons, and DOM manipulation was used to change the button's `textContent` from "Copy Entry" to "Copied!" for 1.5 seconds, providing user feedback. The Spotify Widget was integrated by placing its static `iframe` structure directly into the `about.html` file.
                </li>
                <li><strong>What challenges did you encounter, and how did you solve them?</strong><br>
                    The main challenge was ensuring the dynamically created content from the Storage API worked with the Clipboard API. When a user saves a new entry, the copy button for that entry must also work. I solved this by using an event delegation approach: instead of attaching click listeners directly to each button (which would fail for new buttons), I listened for clicks on the document and checked if the clicked element had the class `copy-button`. This ensures copy functionality works for both static and dynamically created entries.
                </li>
                <li><strong>In what ways do these APIs improve your Learning Journal PWA?</strong><br>
                    These APIs significantly improve the PWA's functionality. The Local Storage gives the application persistence, meaning user-submitted journal entries are never lost. The Clipboard API adds a useful quality-of-life feature, simplifying the sharing or archiving of entries. The Spotify Widget makes the profile page more engaging by integrating external, multimedia content, fulfilling the goal of making the PWA more powerful and interactive.
                </li>
            </ol>
        </article>

        <article class="journal-entry">
            <h2>Week 3: JavaScript & DOM Manipulation (Lab 3)</h2>
            <p id="entry-content-w3">Goal: Enhanced the Learning Journal PWA by adding a reusable navigation menu and an interactive Theme Switcher using JavaScript and the HTML DOM.</p>
            <button class="copy-button" data-target="entry-content-w3">Copy Entry</button>
            <h3>Journal Questions:</h3>
            <ol>
                <li><strong>Which DOM selection methods did you use, and why did you choose them?</strong><br>
                    I used two primary methods: document.getElementById() and document.querySelectorAll(). I chose `getElementById()` (used for selecting the navigation placeholder and the theme button) because it is the fastest method and guaranteed to select only one unique element. I chose `querySelectorAll()` (used for selecting all navigation links) because it returns a list of elements that can be efficiently looped over to apply the active class or attach event listeners.
                </li>
                <li><strong>What was the most challenging part about linking JavaScript with your HTML?</strong><br>
                    The most challenging part was ensuring the reusable navigation code correctly determined which page was currently loaded to apply the `class="active"`. I encountered an error where the script failed to correctly identify the homepage file name (`index.html`) when deployed, leading to incorrect highlighting. This was fixed by implementing logic in JavaScript to specifically check for an empty path and default to 'index.html'.
                </li>
                <li><strong>How did you test and debug your JavaScript code?</strong><br>
                    I primarily tested and debugged using the browser's Developer Tools. I used the Console to check if variables were holding the correct page paths and if functions were running when expected. I used the Elements tab to verify that the `dark-mode` CSS class was being correctly added to the `<body>` element on button clicks, and that the `active` class was being applied to the correct navigation link.
                </li>
            </ol>
        </article>


        <article class="journal-entry">
            <h2>Week 2: Frontend Fundamentals (Lab 2)</h2>
            <p id="entry-content-w2">Goal: Established the basic structure, layout, and navigation of the Learning Journal PWA using only HTML and CSS, with a focus on responsive, mobile-first design.</p>
            <button class="copy-button" data-target="entry-content-w2">Copy Entry</button>
            <h3>Journal Questions:</h3>
            <ol>
                <li><strong>How did you approach mobile-first design?</strong><br>
                    I adopted a mobile-first strategy by ensuring the CSS was written primarily for small screen sizes (phones) by default. I first styled the main elements, such as the body, fonts, and colours. Critically, I used Flexbox on the navigation (nav ul) to stack the links vertically (flex-direction: column), making them large touch targets suitable for mobile. Only after the mobile layout was complete did I use a CSS media query (@media screen and (min-width: 768px)) to override those styles, changing the navigation to a horizontal row and centering the content for tablet and desktop views.
                </li>
                <li><strong>What was the most useful HTML or CSS concept you applied this week?</strong><br>
                    The most useful concept was Flexbox. It was essential for creating a responsive navigation bar. By switching the flex-direction property based on screen size, I maintained layout consistency and adapted the design effectively between mobile and desktop. This satisfied the requirement to build the skeleton structure and design layout using HTML and CSS only.
                </li>
                <li><strong>What part of HTML or CSS did you find most challenging or confusing?</strong><br>
                    The most challenging part was ensuring the "active" page highlighting worked correctly across all four HTML pages (index.html, journal.html, etc.). Since JavaScript was excluded for this week's task, I had to manually place the class="active" tag on the current page's link in each of the four separate HTML files. This repeated manual effort was tedious and highlighted the need for a templating system or JavaScript component loading for navigation reusability in future weeks.
                </li>
            </ol>
        </article>

        <article class="journal-entry">
            <h2>Week 1: Introduction and PWA (Lab 1)</h2>
            <p id="entry-content-w1">Goal: Become familiar with running applications across multiple platforms (GitHub, VS Code, PythonAnywhere, Android Studio) by building the Temperature Converter PWA.</p>
            <button class="copy-button" data-target="entry-content-w1">Copy Entry</button>
            <h3>Lab 1 Reflection and Challenges:</h3>
            <ul>
                <li><strong>Steps Followed & Technologies:</strong> Describe the steps using GitHub, VS Code, PythonAnywhere, Android Studio, PWA, and Kotlin code.<br>
                    The lab began with GitHub setup, creating the Temperature ConverterPWA repository and integrating with VS Code by installing Git and the GitHub extensions. I used VS Code to open the repository remotely, create the initial index.html and commit the changes. Next, I deployed the site using GitHub Pages after changing the repository visibility to public. The PWA was built by adding the **manifest.json** for installability, the main UI (HTML form, converter.css for styling, and converter.js for conversion logic). Finally, a Service Worker (sw.js) was added to enable offline functionality. I also tested deploying the same files to PythonAnywhere and followed instructions to run a Kotlin-based Temperature Converter app in Android Studio.
                </li>
                <li><strong>Challenges Faced:</strong> Describe any difficulties you encountered while running the code or configuring the platforms.<br>
                    One challenge was ensuring the correct relative paths were used for the PWA manifest and Service Worker references (e.g., /manifest.json and /sw.js). Incorrect paths prevented the app from being installed or working offline. Another area of complexity was setting up Android Studio and running the Kotlin app, as it required downloading and configuring SDKs and emulators, which was significantly more complex than the web deployments (GitHub Pages and PythonAnywhere).
                </li>
            </ul>
        </article>

    </main>

    <footer>
        <p>Â© 2025 Ramesh Chaudhary. All rights reserved.</p>
    </footer>

    <script src="{{ url_for('static', filename='js/storage.js') }}"></script>
        <script src="{{ url_for('static', filename='js/browser.js') }}"></script>
            <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
